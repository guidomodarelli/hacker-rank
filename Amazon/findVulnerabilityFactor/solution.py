import math
from typing import List

def gcd(a, b):
    """Calculate GCD of two numbers"""
    while b:
        a, b = b, a % b
    return a

def gcd_of_array(arr):
    """Calculate GCD of an array of numbers"""
    if not arr:
        return 0
    result = arr[0]
    for i in range(1, len(arr)):
        result = gcd(result, arr[i])
        if result == 1:
            break
    return result

def can_achieve_vulnerability_factor(key, max_change, target_factor):
    """Check if we can achieve the target vulnerability factor with at most max_change modifications"""
    n = len(key)

    # If target_factor is 0, we need to make all elements coprime
    if target_factor == 0:
        # Count how many elements need to be changed to make GCD of any pair = 1
        # This is complex, so we'll use a simpler approach
        changes_needed = 0
        for i in range(n - 1):
            if gcd(key[i], key[i + 1]) > 1:
                changes_needed += 1
        return changes_needed <= max_change

    # For target_factor > 0, we need to ensure no subarray of length > target_factor has GCD > 1
    changes_used = 0
    i = 0

    while i < n:
        # Try to find the longest subarray starting at i with GCD > 1
        current_gcd = key[i]
        j = i

        # Extend the subarray as long as GCD > 1
        while j < n and current_gcd > 1:
            current_gcd = gcd(current_gcd, key[j])
            j += 1

        # Length of current subarray with GCD > 1
        length = j - i

        if length > target_factor:
            # We need to break this subarray
            # Greedy: change elements to break it into smaller parts
            changes_needed = length - target_factor
            changes_used += changes_needed

            if changes_used > max_change:
                return False

            # Move to the next potential start
            i = j
        else:
            i = j if j > i else i + 1

    return True

def findVulnerabilityFactor(key: List[int], maxChange: int) -> int:
    """Find the minimum vulnerability factor"""
    n = len(key)

    # Binary search on the answer
    left, right = 0, n
    result = n

    while left <= right:
        mid = (left + right) // 2

        if can_achieve_vulnerability_factor(key, maxChange, mid):
            result = mid
            right = mid - 1
        else:
            left = mid + 1

    return result

# Alternative more precise implementation
def findVulnerabilityFactorOptimal(key: List[int], maxChange: int) -> int:
    """Optimized solution using sliding window approach"""
    n = len(key)

    def min_changes_for_max_length(max_len):
        """Find minimum changes needed to ensure no subarray of length > max_len has GCD > 1"""
        if max_len >= n:
            return 0

        if max_len == 0:
            # Special case: need to make all elements coprime
            return n  # Worst case: change all elements

        changes = 0
        i = 0

        while i < n:
            # Find the longest subarray starting at i with GCD > 1
            j = i
            current_gcd = key[i]

            while j < n:
                current_gcd = gcd(current_gcd, key[j])
                if current_gcd == 1:
                    break
                j += 1

            # Length of subarray with GCD > 1
            length = j - i

            if length > max_len:
                # Need to make changes to break this subarray
                changes += (length - 1) // max_len
                i = j
            else:
                i = j if j > i else i + 1

        return changes

    # Binary search on the answer
    left, right = 0, n

    while left < right:
        mid = (left + right) // 2

        if min_changes_for_max_length(mid) <= maxChange:
            right = mid
        else:
            left = mid + 1

    return left

# Test with the sample
if __name__ == "__main__":
    # Sample test case
    key = [5, 10, 20, 10, 15, 5]
    maxChange = 2
    result = findVulnerabilityFactor(key, maxChange)
    print(f"Result: {result}")  # Expected: 2
